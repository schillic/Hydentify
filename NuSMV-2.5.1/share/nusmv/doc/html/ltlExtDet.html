<HTML>
<HEAD><TITLE>The ltl package</TITLE></HEAD>
<BODY>

<DL>
<dt><pre>
<A NAME="Ltl_CheckLtlSpec"></A>
void <I></I>
<B>Ltl_CheckLtlSpec</B>(
  Prop_ptr  <b>prop</b> <i></i>
)
</pre>
<dd> The main routine to perform LTL model checking. It
  first takes the LTL formula, prints it in a file. It calls the LTL2SMV
  translator on it an reads in the generated tableau. The tableau is
  instantiated, compiled and then conjoined with the original model
  (both the set of fairness conditions and the transition relation are
  affected by this operation, for this reason we save the current
  model, and after the verification of the property we restore the
  original one).

  If already set (The Scalar and the Bdd ones, the FSMs used for
  verification are taken from within the property. Otherwise, global
  FSMs are set within the property and then used for verification.
<p>

<dt><pre>
<A NAME="Ltl_Init"></A>
void <I></I>
<B>Ltl_Init</B>(
   <b></b> <i></i>
)
</pre>
<dd> Initializes the ltl package.
<p>

<dd> <b>Side Effects</b> None
<p>

<dt><pre>
<A NAME="Ltl_RewriteInput"></A>
node_ptr <I></I>
<B>Ltl_RewriteInput</B>(
  SymbTable_ptr  <b>symb_table</b>, <i></i>
  node_ptr  <b>expr</b>, <i></i>
  SymbLayer_ptr  <b>layer</b>, <i></i>
  node_ptr* <b>init</b>, <i></i>
  node_ptr* <b>invar</b>, <i></i>
  node_ptr* <b>trans</b> <i></i>
)
</pre>
<dd> The function takes an LTL formula and rewrite it such a
  way that it will not contain input variables any more. See the
  description of this file for more details.

  "layer" is the later where new state variables are defined (if it is 
  required).

  "init", "invar", "trans" point to expressions corresponding to
  initial condition, invariant and transition relations of the
  hierarchy, respect. This expressions are added new expression if required.
  
  The returned expressions (the LTL formula and parts of hierarchy)
  are newly created node_ptr constructs and have to be freed by the
  invoker. 
  NOTE ABOUT MEMORY: New expressions are created exactly the same way
  as it is done by Compile_FlattenSexpExpandDefine.

  Precondition: input expression has to be already flattened.
<p>

<dt><pre>
<A NAME="Ltl_StructCheckLtlSpec_build_counter_example"></A>
Trace_ptr <I></I>
<B>Ltl_StructCheckLtlSpec_build_counter_example</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b>, <i></i>
  NodeList_ptr  <b>symbols</b> <i></i>
)
</pre>
<dd> Perform the computation of a witness for a property.
  Assumes the Ltl_StructcCheckLtlSpec structure being initialized before with
  Ltl_StructCheckLtlSpec_build, and that Ltl_StructCheckLtlSpec_build has been
  invoked.
<p>

<dt><pre>
<A NAME="Ltl_StructCheckLtlSpec_build"></A>
void <I></I>
<B>Ltl_StructCheckLtlSpec_build</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Initialize the structure by computing the tableau for
  the LTL property and computing the cross-product with the FSM of the model.
<p>

<dt><pre>
<A NAME="Ltl_StructCheckLtlSpec_check"></A>
void <I></I>
<B>Ltl_StructCheckLtlSpec_check</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Perform the check to see wether the property holds or not.
  Assumes the Ltl_StructcCheckLtlSpec structure being initialized before with
  Ltl_StructCheckLtlSpec_build.

  If compassion is present it calls the check method for compassion,
  otherwise the check method dedicated to the algorithm given by the
  value of the oreg_justice_emptiness_bdd_algorithm option.
<p>

<dd> <b>See Also</b> <code><a href="#ltl_stuctcheckltlspec_check_compassion">ltl_stuctcheckltlspec_check_compassion</a>
<a href="#ltl_structcheckltlspec_check_el_bwd">ltl_structcheckltlspec_check_el_bwd</a>
<a href="#ltl_structcheckltlspec_check_el_fwd">ltl_structcheckltlspec_check_el_fwd</a>
</code>

<dt><pre>
<A NAME="Ltl_StructCheckLtlSpec_create"></A>
Ltl_StructCheckLtlSpec_ptr <I></I>
<B>Ltl_StructCheckLtlSpec_create</B>(
  Prop_ptr  <b>prop</b> <i></i>
)
</pre>
<dd> Create an empty Ltl_StructCheckLtlSpec structure.
<p>

<dt><pre>
<A NAME="Ltl_StructCheckLtlSpec_destroy"></A>
void <I></I>
<B>Ltl_StructCheckLtlSpec_destroy</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Desrtroy an Ltl_StructCheckLtlSpec structure.
<p>

<dt><pre>
<A NAME="Ltl_StructCheckLtlSpec_explain"></A>
void <I></I>
<B>Ltl_StructCheckLtlSpec_explain</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b>, <i></i>
  NodeList_ptr  <b>symbols</b> <i></i>
)
</pre>
<dd> Perform the computation of a witness for a property.
  Assumes the Ltl_StructcCheckLtlSpec structure being initialized before with
  Ltl_StructCheckLtlSpec_build, and that Ltl_StructCheckLtlSpec_build has been
  invoked.
<p>

<dt><pre>
<A NAME="Ltl_StructCheckLtlSpec_get_clean_s0"></A>
bdd_ptr <I></I>
<B>Ltl_StructCheckLtlSpec_get_clean_s0</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Get the s0 field  of an Ltl_StructCheckLtlSpec structure
  purified by tableu variables
<p>

<dt><pre>
<A NAME="Ltl_StructCheckLtlSpec_get_s0"></A>
bdd_ptr <I></I>
<B>Ltl_StructCheckLtlSpec_get_s0</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Get the s0 field of an Ltl_StructCheckLtlSpec structure
<p>

<dt><pre>
<A NAME="Ltl_StructCheckLtlSpec_print_result"></A>
void <I></I>
<B>Ltl_StructCheckLtlSpec_print_result</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Prints the result of the Ltl_StructCheckLtlSpec_check fun
<p>

<dt><pre>
<A NAME="Ltl_StructCheckLtlSpec_set_do_rewriting"></A>
void <I></I>
<B>Ltl_StructCheckLtlSpec_set_do_rewriting</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b>, <i></i>
  boolean  <b>do_rewriting</b> <i></i>
)
</pre>
<dd> Set the do_rewriting field of an Ltl_StructCheckLtlSpec
  structure
<p>

<dt><pre>
<A NAME="Ltl_StructCheckLtlSpec_set_ltl2smv"></A>
void <I></I>
<B>Ltl_StructCheckLtlSpec_set_ltl2smv</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b>, <i></i>
  Ltl_StructCheckLtlSpec_ltl2smv  <b>ltl2smv</b> <i></i>
)
</pre>
<dd> Set the ltl2smv field of an Ltl_StructCheckLtlSpec structure
<p>

<dt><pre>
<A NAME="Ltl_StructCheckLtlSpec_set_negate_formula"></A>
void <I></I>
<B>Ltl_StructCheckLtlSpec_set_negate_formula</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b>, <i></i>
  boolean  <b>negate_formula</b> <i></i>
)
</pre>
<dd> Set the negate_formula field of an Ltl_StructCheckLtlSpec structure
<p>

<dt><pre>
<A NAME="Ltl_StructCheckLtlSpec_set_oreg2smv"></A>
void <I></I>
<B>Ltl_StructCheckLtlSpec_set_oreg2smv</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b>, <i></i>
  Ltl_StructCheckLtlSpec_oreg2smv  <b>oreg2smv</b> <i></i>
)
</pre>
<dd> Set the oreg2smv field of an Ltl_StructCheckLtlSpec structure
<p>

<dt><pre>
<A NAME="Ltl_apply_input_vars_rewriting"></A>
Expr_ptr <I></I>
<B>Ltl_apply_input_vars_rewriting</B>(
  Expr_ptr  <b>spec</b>, <i></i>
  SymbTable_ptr  <b>st</b>, <i></i>
  SymbLayer_ptr  <b>layer</b>, <i></i>
  FlatHierarchy_ptr  <b>outfh</b> <i></i>
)
</pre>
<dd> Rewriting makes side-effect on given hierarchy, and
  can declare new variables inside given layer.
  The resulting expression is flattened and define expanded.
  Invoker has to free returned expression exactly as if it was created by
  Compile_FlattenSexpExpandDefine.
<p>

<dd> <b>Side Effects</b> layer and outfh are expected to get changed
<p>

<dd> <b>See Also</b> <code><a href="#Compile_FlattenSexpExpandDefine">Compile_FlattenSexpExpandDefine</a>
</code>

<dt><pre>
<A NAME="ltl_clean_bdd"></A>
bdd_ptr <I></I>
<B>ltl_clean_bdd</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b>, <i></i>
  bdd_ptr  <b>bdd</b> <i></i>
)
</pre>
<dd> Quantify out tableau variables
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="ltl_create_substitution"></A>
node_ptr <I></I>
<B>ltl_create_substitution</B>(
  SymbTable_ptr  <b>symb_table</b>, <i></i>
  node_ptr  <b>expr</b>, <i></i>
  NodeList_ptr  <b>new_var_exprs</b> <i></i>
)
</pre>
<dd> The purpose of the function is to create a substitution
  for the given expression in an LTL formula.

  Returns the new identifiers.
<p>

<dt><pre>
<A NAME="ltl_rewrite_input"></A>
LtlInputKind <I></I>
<B>ltl_rewrite_input</B>(
  SymbTable_ptr  <b>symb_table</b>, <i></i>
  node_ptr* <b>expr</b>, <i></i>
  NodeList_ptr  <b>new_var_exprs</b> <i></i>
)
</pre>
<dd> A copy of the provided expression is created and
  returned in the same pointer "expr". The copy may be exact or
  already rewritten (to remove inputs in temporal expressions).

  "new_var_exprs" is a list of pairs (CONS) of a new state var
  introduced during rewriting and an expression associated with that
  state variable.
  
  Precondition: the expression have to be correctly typed.

  NOTE FOR DEVELOPERS: This function creates new expression using the
  same approach as compileFlattenSexpRecur, i.e. consts and ids are
  find_atom-ed and operations are new_node-ed. Both functions should be 
  changed synchronously.
<p>

<dd> <b>See Also</b> <code><a href="#LtlInputKind">LtlInputKind</a>
</code>

<dt><pre>
<A NAME="ltl_structcheckltlspec_build_tableau_and_prop_fsm"></A>
int <I></I>
<B>ltl_structcheckltlspec_build_tableau_and_prop_fsm</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Creates the tableau for a LTL property.  The FSM of the
  property contains the tableau. Returns 1 if an error is encountered
  during the tableau generation, 0 otherwise
<p>

<dd> <b>Side Effects</b> The bdd fsm into the prop will change
<p>

<dt><pre>
<A NAME="ltl_structcheckltlspec_check_compassion"></A>
void <I></I>
<B>ltl_structcheckltlspec_check_compassion</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Assumes the Ltl_StructcCheckLtlSpec structure being
  initialized before with Ltl_StructCheckLtlSpec_build.
<p>

<dt><pre>
<A NAME="ltl_structcheckltlspec_check_el_bwd"></A>
void <I></I>
<B>ltl_structcheckltlspec_check_el_bwd</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Assumes the Ltl_StructcCheckLtlSpec structure being
  initialized before with Ltl_StructCheckLtlSpec_build.
<p>

<dt><pre>
<A NAME="ltl_structcheckltlspec_check_el_fwd"></A>
void <I></I>
<B>ltl_structcheckltlspec_check_el_fwd</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Assumes the Ltl_StructcCheckLtlSpec structure being
  initialized before with Ltl_StructCheckLtlSpec_build.
<p>

<dt><pre>
<A NAME="ltl_structcheckltlspec_deinit"></A>
void <I></I>
<B>ltl_structcheckltlspec_deinit</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="ltl_structcheckltlspec_init"></A>
void <I></I>
<B>ltl_structcheckltlspec_init</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b>, <i></i>
  Prop_ptr  <b>prop</b> <i></i>
)
</pre>
<dd> optional
<p>

<dd> <b>Side Effects</b> required
<p>

<dd> <b>See Also</b> <code>optional
</code>

<dt><pre>
<A NAME="ltl_structcheckltlspec_prepare"></A>
void <I></I>
<B>ltl_structcheckltlspec_prepare</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Support function for the init function
<p>

<dd> <b>See Also</b> <code><a href="#ltl_structcheckltlspec_init">ltl_structcheckltlspec_init</a>
</code>

<dt><pre>
<A NAME="ltl_structcheckltlspec_remove_layer"></A>
void <I></I>
<B>ltl_structcheckltlspec_remove_layer</B>(
  Ltl_StructCheckLtlSpec_ptr  <b>self</b> <i></i>
)
</pre>
<dd> Private service that removes the given layer from
  the symbol table, and from both the boolean and bdd encodings.
<p>


</DL>
<HR>
Last updated on 2010/10/01 19h:57
</BODY></HTML>
